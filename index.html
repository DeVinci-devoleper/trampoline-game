<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Trampoline Terror Clone - Random Levels + Legend (FINAL WORKING)</title>
    <style>
        body {
            background: #202028;
            color: white;
            display: flex;
            justify-content: center;
            gap: 20px;
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; 
        }
        canvas {
            background: #000;
            border: 4px solid #555;
            image-rendering: pixelated;
        }
        .ui-info {
            margin-top: 10px;
            text-align: center;
            width: 400px;
            font-size: 14px;
            color: #ccc;
        }
        
        /* Стилизация HUD */
        #hud {
            width: 160px;
            background: #444;
            border: 3px solid #777;
            padding: 5px;
            margin-top: 50px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 5px;
        }
        .hud-block { background: #222; padding: 5px; border-radius: 3px; }
        .hud-label { color: #aaa; font-size: 10px; font-weight: bold; margin-bottom: 2px;}
        .hud-value { font-size: 20px; text-align: right; color: #FFD700; font-weight: bold; font-family: monospace; }
        .controls-hint { color: #44FF44; font-weight: bold; }

        /* Стиль для экрана победы и сообщения */
        #victory-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            color: #FFFF00;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            z-index: 10;
            opacity: 0;
            transition: opacity 1s;
        }
        #exit-unlocked-message {
            position: absolute;
            top: 20px;
            width: 90%;
            background: rgba(0, 150, 255, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
        }

        /* Легенда */
        #legend {
            margin-top: 20px;
            padding: 10px;
            width: 400px;
            background: #333;
            border: 1px solid #666;
            border-radius: 5px;
            text-align: left;
            font-size: 12px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 10px;
            border: 1px solid #000;
            box-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>

    <div id="game-container">
        <h2>Trampoline Terror: Random Levels + Legend (FINAL WORKING)</h2>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        
        <div id="exit-unlocked-message">
            ВЫХОД РАЗБЛОКИРОВАН! Найдите фиолетовую плитку!
        </div>

        <div id="victory-screen">
            <div class="victory-text">ПОБЕДА!</div>
            <div>ВЫ ПРОШЛИ 5 СЛУЧАЙНЫХ УРОВНЕЙ!</div>
            <div style="font-size: 18px; color: #ccc; margin-top: 20px;">Поздравляем!</div>
        </div>

        <div class="ui-info">
            <p>Перемещение: <b>Стрелки</b> | Прыжок: <b>Пробел</b></p>
            <p class="controls-hint">Атака: Клавиша Z (Тратит P-Ball)</p>
        </div>

        <div id="legend">
            <h3 style="margin-top: 0; color: #FFD700;">ЛЕГЕНДА</h3>
            <div class="legend-item">
                <div class="legend-color" style="background: #44FF44;"></div> 
                Трамплин (3 жизни)
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF4444;"></div> 
                Трамплин (1 жизнь)
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #111; border: none; box-shadow: none;"></div> 
                Дыра (Опасно!)
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #A020F0;"></div> 
                Выход (6) - Активируется после выполнения цели
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFFF00;"></div> 
                **Switch (5) - ЦЕЛЬ УРОВНЯ!** (Собери все)
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4080FF;"></div> 
                P-Ball (4) - Боеприпасы (Синий)
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00CC00;"></div> 
                **Враг** (Зеленый квадрат)
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFFFFF;"></div> 
                Снаряд P-Ball (Белый круг)
            </div>
        </div>
    </div>

    <div id="hud">
        <div class="hud-block">
            <div class="hud-label">SCORE</div>
            <div id="score" class="hud-value">00000</div>
        </div>
        <div class="hud-block">
            <div class="hud-label">LIVES</div>
            <div id="lives" class="hud-value">3</div>
        </div>
        <div class="hud-block">
            <div class="hud-label">STAGE</div>
            <div id="stage" class="hud-value">1</div>
        </div>
        <div class="hud-block">
            <div class="hud-label">SWITCHES</div>
            <div id="switch-count" class="hud-value">0</div>
        </div>
        <div class="hud-block" style="border: 1px solid #4080FF;">
            <div class="hud-label" style="color: #4080FF">P-BALL (AMMO)</div>
            <div id="pball-count" class="hud-value" style="color: #FFF">5</div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const victoryScreen = document.getElementById('victory-screen');
    const exitMessage = document.getElementById('exit-unlocked-message');

    // --- КОНФИГУРАЦИЯ ---
    const TILE_SIZE = 40; 
    const COLS = 10;
    const ROWS = 10;
    const MAX_LEVELS = 5; 

    const ENEMY_COLOR = '#00CC00'; 
    const MOVE_SPEED = 0.1; 

    const COLORS = {
        0: '#111', 1: '#FF4444', 2: '#FFD700', 3: '#44FF44', 
        4: '#4080FF', 
        5: '#FFFF00', 
        6: '#A020F0', 
        9: '#888888' 
    };

    let currentLevelIndex = 0;
    let map = [];
    let score = 0;
    let lives = 3; 
    let switchesRemaining = 0;
    let pBalls = 5; 
    let gameOver = false;
    let gameWon = false;
    let exitEnabled = false; 
    let playerStartPos = { x: 1, y: 1 };

    // --- ИГРОК ---
    const player = {
        x: 0, y: 0, color: '#FFFFFF', isJumping: false, jumpHeight: 0,     
        targetX: 0, targetY: 0, moving: false, moveProgress: 0,
        lastDx: 1, lastDy: 0 
    };

    // --- ВРАГИ И СНАРЯДЫ ---
    let enemies = [];
    let projectiles = []; 
    let explosions = [];  

    // Объект для отслеживания нажатых клавиш
    const keys = {};
    let zKeyPressed = false; 

    // --- УПРАВЛЕНИЕ ---
    // Убедимся, что window.keys не конфликтует с локальным объектом keys
    window.addEventListener('keydown', e => { 
        keys[e.code] = true;
        // Отменяем действие по умолчанию для стрелок и пробела
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
            e.preventDefault();
        }
    });
    window.addEventListener('keyup', e => {
        keys[e.code] = false;
        if (e.code === 'KeyZ') zKeyPressed = false; 
    });

    // =========================================================
    // ГЕНЕРАЦИЯ СЛУЧАЙНЫХ ДАННЫХ 
    // =========================================================

    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function generateRandomMap() {
        const newMap = [];
        const floorTiles = [];
        
        for (let y = 0; y < ROWS; y++) {
            newMap[y] = [];
            for (let x = 0; x < COLS; x++) {
                if (x === 0 || x === COLS - 1 || y === 0 || y === ROWS - 1) {
                    newMap[y][x] = 9;
                } else {
                    if (Math.random() < 0.7) {
                        newMap[y][x] = 3; 
                        floorTiles.push({ x, y });
                    } else {
                        newMap[y][x] = 0;
                    }
                }
            }
        }

        const requiredFloorTiles = floorTiles.filter(t => t.x !== 1 || t.y !== 1);
        newMap[1][1] = 3; 
        playerStartPos = { x: 1, y: 1 };
        const totalSwitches = getRandomInt(1, 3);
        const totalPballs = getRandomInt(1, 2);
        switchesRemaining = totalSwitches;

        const itemsToPlace = [
            ...Array(totalSwitches).fill(5), 
            ...Array(totalPballs).fill(4)
        ];

        while (itemsToPlace.length > 0 && requiredFloorTiles.length > 0) {
            const index = getRandomInt(0, requiredFloorTiles.length - 1);
            const { x, y } = requiredFloorTiles[index];
            
            newMap[y][x] = itemsToPlace.pop();
            requiredFloorTiles.splice(index, 1);
        }
        
        if (requiredFloorTiles.length > 0) {
            const index = getRandomInt(0, requiredFloorTiles.length - 1);
            const { x, y } = requiredFloorTiles[index];
            newMap[y][x] = 6;
        } else {
            newMap[1][2] = 6;
        }

        return newMap;
    }

    function generateRandomEnemies() {
        const enemiesStart = [];
        const floorTiles = [];

        for (let y = 1; y < ROWS - 1; y++) {
            for (let x = 1; x < COLS - 1; x++) {
                const type = map[y][x];
                if (type !== 0 && type !== 9 && (x !== playerStartPos.x || y !== playerStartPos.y)) {
                    floorTiles.push({ x, y });
                }
            }
        }
        
        const numEnemies = getRandomInt(2, 4);

        for (let i = 0; i < numEnemies && floorTiles.length > 0; i++) {
            const index = getRandomInt(0, floorTiles.length - 1);
            const { x, y } = floorTiles[index];

            enemiesStart.push({
                x: x, 
                y: y, 
                direction: Math.random() < 0.5 ? 1 : -1,
                speed: getRandomInt(3, 8) / 100,
                moveProgress: 0 // Убеждаемся, что прогресс начинается с 0
            });
            floorTiles.splice(index, 1);
        }

        return enemiesStart;
    }


    // =========================================================
    // ЛОГИКА ИГРЫ
    // =========================================================

    function loadLevel(levelIndex) {
        if (levelIndex >= MAX_LEVELS) {
            handleGameWin();
            return;
        }
        currentLevelIndex = levelIndex;
        
        map = generateRandomMap();
        enemies = generateRandomEnemies();

        player.x = playerStartPos.x;
        player.y = playerStartPos.y;
        player.targetX = player.x;
        player.targetY = player.y;
        player.moving = false;
        player.isJumping = false;
        player.moveProgress = 0; // Сброс прогресса движения
        player.lastDx = 1;
        player.lastDy = 0;
        
        projectiles = [];
        explosions = [];
        gameOver = false;
        gameWon = false;
        exitEnabled = false; 
        victoryScreen.style.opacity = 0;
        exitMessage.style.opacity = 0;

        updateHUD();
    }
    
    function updateHUD() {
        document.getElementById('score').innerText = score.toString().padStart(5, '0');
        document.getElementById('lives').innerText = lives;
        document.getElementById('stage').innerText = currentLevelIndex + 1; 
        document.getElementById('switch-count').innerText = switchesRemaining;
        document.getElementById('pball-count').innerText = pBalls;
    }
    
    function checkExitUnlock() {
        if (switchesRemaining === 0 && enemies.length === 0 && !exitEnabled) {
            exitEnabled = true;
            exitMessage.innerText = "ВЫХОД РАЗБЛОКИРОВАН! Найдите фиолетовую плитку!";
            exitMessage.style.backgroundColor = 'rgba(0, 150, 255, 0.8)';
            exitMessage.style.opacity = 1;
            setTimeout(() => { exitMessage.style.opacity = 0; }, 3000);
        }
    }

    function handleGameWin() {
        gameWon = true;
        gameOver = true;
        victoryScreen.style.opacity = 1;
    }

    function handleHit() {
        if (gameOver || gameWon) return;
        lives--;
        if (lives <= 0) {
            gameOver = true;
            alert("Game Over! Попробуйте снова.");
            currentLevelIndex = 0;
            lives = 3;
            score = 0;
            pBalls = 5;
            loadLevel(currentLevelIndex); 
            return;
        }
        
        player.x = playerStartPos.x; 
        player.y = playerStartPos.y;
        player.targetX = player.x; player.targetY = player.y;
        player.moving = false;
        player.isJumping = false;
        player.moveProgress = 0; // Сброс прогресса движения
        
        updateHUD();
    }
    
    function landOnTile(gx, gy) {
        const tileType = map[gy][gx];

        if (tileType === 0) {
            handleHit(); 
            return;
        }

        if (tileType >= 1 && tileType <= 3) {
            map[gy][gx] -= 1; 
            score += 10;
        } else if (tileType === 5) { 
            switchesRemaining = Math.max(0, switchesRemaining - 1);
            score += 100;
            map[gy][gx] = 9;
            checkExitUnlock(); 
        } else if (tileType === 4) { 
            pBalls += 3; 
            score += 50; 
            map[gy][gx] = 9;
        } else if (tileType === 6) { 
            if (exitEnabled) {
                setTimeout(() => {
                    loadLevel(currentLevelIndex + 1);
                }, 100); 
            } else {
                exitMessage.innerText = "Сначала нужно собрать все SWITCHES и убить всех врагов!";
                exitMessage.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
                exitMessage.style.opacity = 1;
                setTimeout(() => { exitMessage.style.opacity = 0; }, 3000);
            }
        }

        updateHUD();
    }
    
    function triggerJump() { player.isJumping = true; }

    function updateProjectiles() {
        for (let i = 0; i < projectiles.length; i++) {
            let p = projectiles[i];
            if (!p.active) continue;
            p.progress += p.speed;
            if (p.progress >= 1) {
                p.x += p.dx; p.y += p.dy; p.progress = 0;
                if (p.x < 0 || p.x >= COLS || p.y < 0 || p.y >= ROWS || map[p.y][p.x] === 9) {
                    p.active = false; continue;
                }
            }
            let pRenderX = (p.x * TILE_SIZE) + (p.dx * TILE_SIZE * p.progress) + TILE_SIZE / 2;
            let pRenderY = (p.y * TILE_SIZE) + (p.dy * TILE_SIZE * p.progress) + TILE_SIZE / 2;
            for (let j = 0; j < enemies.length; j++) {
                let e = enemies[j];
                let eRenderX = e.x * TILE_SIZE;
                if (e.moveProgress > 0) { eRenderX += (e.targetX - e.x) * TILE_SIZE * e.moveProgress; }
                let eCenterY = e.y * TILE_SIZE + TILE_SIZE / 2;
                let dist = Math.hypot(pRenderX - (eRenderX + TILE_SIZE / 2), pRenderY - eCenterY);
                if (dist < TILE_SIZE / 2) { 
                    p.active = false;
                    enemies.splice(j, 1); 
                    createExplosion(e.x, e.y); 
                    score += 200; updateHUD(); checkExitUnlock(); 
                    break;
                }
            }
        }
        projectiles = projectiles.filter(p => p.active);
    }

    function createExplosion(x, y) {
        explosions.push({ x: x, y: y, timer: 10 }); 
    }
    function updateExplosions() {
        for (let i = explosions.length - 1; i >= 0; i--) {
            explosions[i].timer--;
            if (explosions[i].timer <= 0) { explosions.splice(i, 1); }
        }
    }


    // --- ОСНОВНОЙ ЦИКЛ ИГРЫ (UPDATE) ---

    function update() {
        if (gameOver || gameWon) return;

        // 1. Логика стрельбы
        if (keys['KeyZ'] && !zKeyPressed && pBalls > 0) {
            pBalls--;
            projectiles.push({
                x: player.x, y: player.y, dx: player.lastDx, dy: player.lastDy,
                progress: 0, speed: 0.2, active: true
            });
            zKeyPressed = true;
            updateHUD();
        }
        updateProjectiles();
        updateExplosions();

        // 2. Логика врагов (Движение)
        enemies.forEach(enemy => {
            if (enemy.moveProgress > 0) {
                enemy.moveProgress += enemy.speed;
                if (enemy.moveProgress >= 1) {
                    enemy.x = enemy.targetX; enemy.y = enemy.targetY; enemy.moveProgress = 0;
                }
            } else {
                let nextX = enemy.x + enemy.direction;
                if (nextX >= 0 && nextX < COLS && map[enemy.y][nextX] !== 0 && map[enemy.y][nextX] !== 9) {
                    enemy.targetX = nextX; 
                    enemy.moveProgress = 0.01; 
                } else {
                    enemy.direction *= -1; 
                }
            }
        });

        // 3. Коллизия Игрок-Враг
        const isPlayerSafe = player.jumpHeight > 10;
        if (!isPlayerSafe) {
             for (const enemy of enemies) {
                if (player.x === enemy.x && player.y === enemy.y) {
                    const isEnemyOnTile = enemy.moveProgress < 0.2 || enemy.moveProgress > 0.8 || enemy.moveProgress === 0;
                    if (isEnemyOnTile) {
                        handleHit();
                        return;
                    }
                }
            }
        }
        
        // 4. Логика движения Игрока (ВВОД)
        if (!player.moving && !player.isJumping) {
            let dx = 0, dy = 0;
            // Проверяем, какая стрелка нажата, и устанавливаем направление
            if (keys['ArrowUp']) dy = -1;
            else if (keys['ArrowDown']) dy = 1;
            else if (keys['ArrowLeft']) dx = -1;
            else if (keys['ArrowRight']) dx = 1;

            if (dx !== 0 || dy !== 0) { 
                player.lastDx = dx; player.lastDy = dy; 
                
                const nextX = player.x + dx;
                const nextY = player.y + dy;
                
                // Проверяем, что следующая клетка не стена (9)
                if (nextX >= 0 && nextX < COLS && nextY >= 0 && nextY < ROWS && map[nextY][nextX] !== 9) {
                    player.targetX = nextX; player.targetY = nextY;
                    player.moving = true; 
                    triggerJump(); // Прыжок запускается при начале движения
                }
            } else if (keys['Space']) {
                // Прыжок на месте, если нет движения
                triggerJump(); 
            }
        }

        // 5. Анимация движения/прыжка
        if (player.moving || player.isJumping) {
            // Движение вперед, если moving=true
            if (player.moving) {
                player.moveProgress += MOVE_SPEED; 
            } else if (player.isJumping && player.moveProgress < 0.5) {
                // Если только прыгаем на месте, даем ему небольшой прогресс
                 player.moveProgress += 0.05; 
            }
            
            // Расчет высоты прыжка
            player.jumpHeight = Math.sin(player.moveProgress * Math.PI) * 15;
            
            // Завершение хода
            if (player.moveProgress >= 1) {
                player.x = player.targetX; player.y = player.targetY;
                player.moving = false; player.isJumping = false;
                player.moveProgress = 0; player.jumpHeight = 0;
                landOnTile(player.x, player.y);
            } else if (!player.moving && player.isJumping && player.moveProgress >= 0.5) {
                // Если был прыжок на месте, быстро сбрасываем его
                player.isJumping = false;
                player.moveProgress = 0;
                player.jumpHeight = 0;
            }
        }
    }


    // --- ФУНКЦИЯ ОТРИСОВКИ (Draw) ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Отрисовка карты
        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                const t = map[y][x];
                ctx.fillStyle = COLORS[t];
                ctx.fillRect(x * TILE_SIZE + 1, y * TILE_SIZE + 1, TILE_SIZE - 2, TILE_SIZE - 2);
                
                if (t === 6 && exitEnabled) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.moveTo(x * TILE_SIZE + 10, y * TILE_SIZE + 20);
                    ctx.lineTo(x * TILE_SIZE + 30, y * TILE_SIZE + 20);
                    ctx.lineTo(x * TILE_SIZE + 20, y * TILE_SIZE + 10);
                    ctx.closePath();
                    ctx.fill();
                } else if (t >= 1 && t <= 3) {
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.beginPath(); ctx.arc(x*TILE_SIZE+20, y*TILE_SIZE+20, 5, 0, Math.PI*2); ctx.fill();
                }
            }
        }

        // Отрисовка врагов
        enemies.forEach(e => {
            let rx = e.x * TILE_SIZE, ry = e.y * TILE_SIZE;
            if (e.moveProgress > 0) {
                rx += (e.targetX - e.x) * TILE_SIZE * e.moveProgress;
                ry += (e.targetY - e.y) * TILE_SIZE * e.moveProgress;
            }
            ctx.fillStyle = ENEMY_COLOR; 
            ctx.fillRect(rx + 8, ry + 8, 24, 24);
        });

        // Отрисовка снарядов
        ctx.fillStyle = '#FFF';
        projectiles.forEach(p => {
            let px = (p.x * TILE_SIZE) + (p.dx * TILE_SIZE * p.progress) + 20;
            let py = (p.y * TILE_SIZE) + (p.dy * TILE_SIZE * p.progress) + 20;
            ctx.beginPath(); ctx.arc(px, py, 6, 0, Math.PI*2); ctx.fill();
        });

        // Отрисовка взрывов
        ctx.fillStyle = '#FFA500';
        explosions.forEach(e => {
            let ex = e.x * TILE_SIZE + 20;
            let ey = e.y * TILE_SIZE + 20;
            ctx.beginPath(); ctx.arc(ex, ey, 20 + Math.random()*10, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FFFF00';
            ctx.beginPath(); ctx.arc(ex, ey, 10, 0, Math.PI*2); ctx.fill();
        });

        // Отрисовка игрока
        let px = player.x * TILE_SIZE, py = player.y * TILE_SIZE;
        if (player.moving) {
            px += (player.targetX - player.x) * TILE_SIZE * player.moveProgress;
            py += (player.targetY - player.y) * TILE_SIZE * player.moveProgress;
        }
        let vy = py - player.jumpHeight;
        
        ctx.fillStyle = player.color;
        ctx.beginPath(); ctx.arc(px + 20, vy + 20, 12, 0, Math.PI*2); ctx.fill();

        let eyeX = px + 20 + player.lastDx * 8;
        let eyeY = vy + 20 + player.lastDy * 8;
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(eyeX, eyeY, 4, 0, Math.PI*2); ctx.fill();
    }

    // --- ГЛАВНЫЙ ЦИКЛ И АНИМАЦИЯ ---
    function loop() {
        update();
        draw();
        requestAnimationFrame(loop); 
    }

    loadLevel(currentLevelIndex);
    loop(); 
</script>
</body>
</html>