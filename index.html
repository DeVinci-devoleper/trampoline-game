<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Trampoline Terror Clone - Exit Tile Update</title>
    <style>
        body {
            background: #202028;
            color: white;
            display: flex;
            justify-content: center;
            gap: 20px;
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; 
        }
        canvas {
            background: #000;
            border: 4px solid #555;
            image-rendering: pixelated;
        }
        .ui-info {
            margin-top: 10px;
            text-align: center;
            width: 400px;
            font-size: 14px;
            color: #ccc;
        }
        
        /* Стилизация HUD */
        #hud {
            width: 160px;
            background: #444;
            border: 3px solid #777;
            padding: 5px;
            margin-top: 50px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 5px;
        }
        .hud-block { background: #222; padding: 5px; border-radius: 3px; }
        .hud-label { color: #aaa; font-size: 10px; font-weight: bold; margin-bottom: 2px;}
        .hud-value { font-size: 20px; text-align: right; color: #FFD700; font-weight: bold; font-family: monospace; }
        .controls-hint { color: #44FF44; font-weight: bold; }

        /* Стиль для экрана победы */
        #victory-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            color: #FFFF00;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            z-index: 10;
            opacity: 0;
            transition: opacity 1s;
        }
        .victory-text {
            color: #44FF44;
            margin-bottom: 20px;
        }

        /* Стиль для сообщения о разблокировке выхода */
        #exit-unlocked-message {
            position: absolute;
            top: 20px;
            width: 90%;
            background: rgba(0, 150, 255, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <h2>Trampoline Terror: Exit Tile Update</h2>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        
        <div id="exit-unlocked-message">
            ВЫХОД РАЗБЛОКИРОВАН! Найдите фиолетовую плитку!
        </div>

        <div id="victory-screen">
            <div class="victory-text">ПОБЕДА!</div>
            <div>ВЫ ПРОШЛИ ИГРУ!</div>
            <div style="font-size: 18px; color: #ccc; margin-top: 20px;">Поздравляем!</div>
        </div>

        <div class="ui-info">
            <p>Перемещение: <b>Стрелки</b> | Прыжок: <b>Пробел</b></p>
            <p class="controls-hint">Атака: Клавиша Z (Тратит P-Ball)</p>
        </div>
    </div>

    <div id="hud">
        <div class="hud-block">
            <div class="hud-label">SCORE</div>
            <div id="score" class="hud-value">00000</div>
        </div>
        <div class="hud-block">
            <div class="hud-label">LIVES</div>
            <div id="lives" class="hud-value">3</div>
        </div>
        <div class="hud-block">
            <div class="hud-label">STAGE</div>
            <div id="stage" class="hud-value">1</div>
        </div>
        <div class="hud-block">
            <div class="hud-label">SWITCHES</div>
            <div id="switch-count" class="hud-value">10</div>
        </div>
        <div class="hud-block" style="border: 1px solid #4080FF;">
            <div class="hud-label" style="color: #4080FF">P-BALL (AMMO)</div>
            <div id="pball-count" class="hud-value" style="color: #FFF">5</div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const victoryScreen = document.getElementById('victory-screen');
    const exitMessage = document.getElementById('exit-unlocked-message');

    // --- КОНФИГУРАЦИЯ ---
    const TILE_SIZE = 40; 
    const COLS = 10;
    const ROWS = 10;

    // 0: Дырка, 1-3: Трамплин, 4: P-Ball, 5: Switch, 6: EXIT, 9: Бетон
    const COLORS = {
        0: '#111', 1: '#FF4444', 2: '#FFD700', 3: '#44FF44', 
        4: '#4080FF', 5: '#AAAAAA', 
        6: '#A020F0', // НОВАЯ ПЛИТКА: ЯРКО-ФИОЛЕТОВЫЙ (EXIT)
        9: '#888888'
    };

    // --- ДАННЫЕ УРОВНЕЙ ---
    const LEVELS = [
        // Level 1: Введение
        {
            mapData: [
                [9,9,9,9,9,9,9,9,9,9],
                [9,3,3,3,9,3,3,3,3,9],
                [9,3,5,3,9,3,4,4,3,9], 
                [9,3,3,3,0,3,3,3,3,9],
                [9,9,9,9,9,9,9,9,9,9],
                [9,3,3,3,3,3,3,3,3,9],
                [9,3,1,1,1,1,1,1,3,9],
                [9,3,3,3,3,3,3,3,6,9], // <--- Плитка EXIT (6)
                [9,9,9,9,9,9,9,9,9,9],
                [9,9,9,9,9,9,9,9,9,9]
            ],
            playerStart: { x: 1, y: 1 },
            switchesTotal: 1,
            enemiesStart: [
                { x: 6, y: 6, direction: 1, speed: 0.03 },
                { x: 2, y: 7, direction: 1, speed: 0.05 }
            ]
        },
        // Level 2: Финал
        {
            mapData: [
                [9,9,9,9,9,9,9,9,9,9],
                [9,1,2,3,3,3,2,1,9,9],
                [9,0,3,1,0,3,1,3,9,9],
                [9,3,5,3,4,3,3,5,9,9], 
                [9,9,9,0,9,0,9,9,9,9],
                [9,3,3,3,3,3,3,3,3,9],
                [9,1,0,1,0,1,0,1,3,9],
                [9,3,3,3,3,3,3,3,6,9], // <--- Плитка EXIT (6)
                [9,9,9,9,9,9,9,9,9,9],
                [9,9,9,9,9,9,9,9,9,9]
            ],
            playerStart: { x: 1, y: 1 },
            switchesTotal: 2,
            enemiesStart: [
                { x: 2, y: 6, direction: 1, speed: 0.05 },
                { x: 7, y: 6, direction: -1, speed: 0.05 },
                { x: 5, y: 1, direction: 1, speed: 0.07 }
            ]
        }
    ];

    let currentLevelIndex = 0;
    let map = [];
    let score = 0;
    let lives = 3; 
    let switchesRemaining = 0;
    let pBalls = 5; 
    let gameOver = false;
    let gameWon = false;
    let exitEnabled = false; // НОВЫЙ ФЛАГ: Разблокирован ли выход

    // --- ИГРОК ---
    const player = {
        x: 0, y: 0, color: '#FFFFFF', isJumping: false, jumpHeight: 0,     
        targetX: 0, targetY: 0, moving: false, moveProgress: 0,
        lastDx: 1, lastDy: 0 
    };

    // --- ВРАГИ И СНАРЯДЫ ---
    let enemies = [];
    let projectiles = []; 
    let explosions = [];  

    const keys = {};
    let zKeyPressed = false; 

    // --- УПРАВЛЕНИЕ ---
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => {
        keys[e.code] = false;
        if (e.code === 'KeyZ') zKeyPressed = false; 
    });

    // --- ФУНКЦИИ ЛОГИКИ И УРОВНЕЙ ---

    function loadLevel(levelIndex) {
        if (levelIndex >= LEVELS.length) {
            handleGameWin();
            return;
        }

        const levelData = LEVELS[levelIndex];
        currentLevelIndex = levelIndex;
        
        // 1. Загрузка карты (Создаем копию)
        map = levelData.mapData.map(row => [...row]); 

        // 2. Сброс игрока
        player.x = levelData.playerStart.x;
        player.y = levelData.playerStart.y;
        player.targetX = player.x;
        player.targetY = player.y;
        player.moving = false;
        player.isJumping = false;
        player.lastDx = 1;
        player.lastDy = 0;

        // 3. Инициализация врагов
        enemies = levelData.enemiesStart.map(e => ({
            ...e,
            moveProgress: 0, 
            targetX: e.x, 
            targetY: e.y 
        }));
        
        // 4. Сброс состояния уровня
        switchesRemaining = levelData.switchesTotal;
        projectiles = [];
        explosions = [];
        gameOver = false;
        gameWon = false;
        exitEnabled = false; // Выход заблокирован в начале уровня
        victoryScreen.style.opacity = 0;
        exitMessage.style.opacity = 0;

        updateHUD();
    }
    
    function updateHUD() {
        document.getElementById('score').innerText = score.toString().padStart(5, '0');
        document.getElementById('lives').innerText = lives;
        document.getElementById('stage').innerText = currentLevelIndex + 1;
        document.getElementById('switch-count').innerText = switchesRemaining;
        document.getElementById('pball-count').innerText = pBalls;
    }
    
    // НОВАЯ ЛОГИКА: Проверка, разблокирован ли выход
    function checkExitUnlock() {
        // Условие: Собраны все свитчи И убиты все враги
        if (switchesRemaining === 0 && enemies.length === 0 && !exitEnabled) {
            exitEnabled = true;
            // Показываем сообщение
            exitMessage.style.opacity = 1;
            setTimeout(() => { exitMessage.style.opacity = 0; }, 3000);
        }
    }

    function handleGameWin() {
        gameWon = true;
        gameOver = true;
        victoryScreen.style.opacity = 1;
    }

    function handleHit() {
        if (gameOver || gameWon) return;

        lives--;
        if (lives <= 0) {
            gameOver = true;
            alert("Game Over! Попробуйте снова.");
            // Перезагрузка всей игры
            currentLevelIndex = 0;
            lives = 3;
            score = 0;
            pBalls = 5;
            loadLevel(currentLevelIndex); 
            return;
        }
        
        // Сброс игрока на стартовую позицию текущего уровня
        const start = LEVELS[currentLevelIndex].playerStart;
        player.x = start.x; player.y = start.y;
        player.targetX = start.x; player.targetY = start.y;
        player.moving = false;
        player.isJumping = false;
        
        updateHUD();
    }
    
    // Приземление - Главная механика игры
    function landOnTile(gx, gy) {
        const tileType = map[gy][gx];

        if (tileType === 0) {
            handleHit(); 
            return;
        }

        if (tileType >= 1 && tileType <= 3) {
            map[gy][gx] -= 1; 
            score += 10;
        } else if (tileType === 5) { 
            switchesRemaining = Math.max(0, switchesRemaining - 1);
            score += 100;
            map[gy][gx] = 9;
            checkExitUnlock(); // Проверяем, разблокирован ли выход
        } else if (tileType === 4) { 
            pBalls += 3; 
            score += 50; 
            map[gy][gx] = 9;
        } else if (tileType === 6) { // НОВАЯ ЛОГИКА: Плитка EXIT
            if (exitEnabled) {
                 // Переход на следующий уровень с небольшой задержкой для плавности
                setTimeout(() => {
                    loadLevel(currentLevelIndex + 1);
                }, 100); 
            } else {
                // Выход заблокирован
                exitMessage.innerText = "Сначала нужно собрать все SWITCHES и убить всех врагов!";
                exitMessage.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
                exitMessage.style.opacity = 1;
                setTimeout(() => { exitMessage.style.opacity = 0; }, 3000);
                exitMessage.style.backgroundColor = 'rgba(0, 150, 255, 0.8)'; // Сброс цвета
            }
        }

        updateHUD();
    }
    
    // ЛОГИКА КОЛЛИЗИИ СНАРЯДОВ
    function updateProjectiles() {
        for (let i = 0; i < projectiles.length; i++) {
            let p = projectiles[i];
            if (!p.active) continue;

            p.progress += p.speed;

            if (p.progress >= 1) {
                p.x += p.dx;
                p.y += p.dy;
                p.progress = 0;

                // Проверка границ/стен
                if (p.x < 0 || p.x >= COLS || p.y < 0 || p.y >= ROWS || map[p.y][p.x] === 9) {
                    p.active = false; 
                    continue;
                }
            }

            // Коллизия с ВРАГАМИ
            let pRenderX = (p.x * TILE_SIZE) + (p.dx * TILE_SIZE * p.progress) + TILE_SIZE / 2;
            let pRenderY = (p.y * TILE_SIZE) + (p.dy * TILE_SIZE * p.progress) + TILE_SIZE / 2;

            for (let j = 0; j < enemies.length; j++) {
                let e = enemies[j];
                
                let eRenderX = e.x * TILE_SIZE;
                let eRenderY = e.y * TILE_SIZE;
                
                if (e.moveProgress > 0) {
                    eRenderX += (e.targetX - e.x) * TILE_SIZE * e.moveProgress;
                }
                
                let eCenterX = eRenderX + TILE_SIZE / 2;
                let eCenterY = eRenderY + TILE_SIZE / 2;

                let dist = Math.hypot(pRenderX - eCenterX, pRenderY - eCenterY);
                
                if (dist < TILE_SIZE / 2) { 
                    // ПОПАДАНИЕ!
                    p.active = false;
                    enemies.splice(j, 1); 
                    createExplosion(e.x, e.y); 
                    score += 200;
                    updateHUD();
                    checkExitUnlock(); // Проверяем, разблокирован ли выход
                    break;
                }
            }
        }
        projectiles = projectiles.filter(p => p.active);
    }

    function createExplosion(x, y) {
        explosions.push({ x: x, y: y, timer: 10 }); 
    }
    function updateExplosions() {
        for (let i = explosions.length - 1; i >= 0; i--) {
            explosions[i].timer--;
            if (explosions[i].timer <= 0) {
                explosions.splice(i, 1);
            }
        }
    }
    function triggerJump() { player.isJumping = true; }

    // --- ОСНОВНОЙ ЦИКЛ ИГРЫ (UPDATE) ---

    function update() {
        if (gameOver || gameWon) return;

        // 1. Логика стрельбы (Z)
        if (keys['KeyZ'] && !zKeyPressed && pBalls > 0) {
            pBalls--;
            projectiles.push({
                x: player.x, y: player.y, dx: player.lastDx, dy: player.lastDy,
                progress: 0, speed: 0.2, active: true
            });
            zKeyPressed = true;
            updateHUD();
        }
        updateProjectiles();
        updateExplosions();

        // 2. Логика врагов
        enemies.forEach(enemy => {
            if (enemy.moveProgress > 0) {
                enemy.moveProgress += enemy.speed;
                if (enemy.moveProgress >= 1) {
                    enemy.x = enemy.targetX; enemy.y = enemy.targetY; enemy.moveProgress = 0;
                }
            } else {
                let nextX = enemy.x + enemy.direction;
                if (nextX >= 0 && nextX < COLS && map[enemy.y][nextX] !== 0 && map[enemy.y][nextX] !== 9) {
                    enemy.targetX = nextX; enemy.moveProgress = 0.01;
                } else {
                    enemy.direction *= -1;
                }
            }
        });

        // 3. Коллизия Игрок-Враг
        const isPlayerSafe = player.jumpHeight > 10;
        if (!isPlayerSafe) {
             for (const enemy of enemies) {
                if (player.x === enemy.x && player.y === enemy.y) {
                    const isEnemyOnTile = enemy.moveProgress < 0.2 || enemy.moveProgress > 0.8 || enemy.moveProgress === 0;
                    if (isEnemyOnTile) {
                        handleHit();
                        return;
                    }
                }
            }
        }
        
        // 4. Логика движения Игрока
        if (!player.moving && !player.isJumping) {
            let dx = 0, dy = 0;
            if (keys['ArrowUp']) dy = -1;
            else if (keys['ArrowDown']) dy = 1;
            else if (keys['ArrowLeft']) dx = -1;
            else if (keys['ArrowRight']) dx = 1;

            if (dx !== 0 || dy !== 0) { player.lastDx = dx; player.lastDy = dy; }
            if (keys['Space']) triggerJump();

            if (dx !== 0 || dy !== 0) {
                const nextX = player.x + dx;
                const nextY = player.y + dy;
                if (nextX >= 0 && nextX < COLS && nextY >= 0 && nextY < ROWS) {
                    player.targetX = nextX; player.targetY = nextY;
                    player.moving = true; triggerJump();
                }
            }
        }

        // 5. Анимация движения/прыжка
        if (player.moving || player.isJumping) {
            player.moveProgress += 0.1; 
            player.jumpHeight = Math.sin(player.moveProgress * Math.PI) * 15;
            if (player.moveProgress >= 1) {
                player.x = player.targetX; player.y = player.targetY;
                player.moving = false; player.isJumping = false;
                player.moveProgress = 0; player.jumpHeight = 0;
                landOnTile(player.x, player.y);
            }
        }
    }


    // --- ФУНКЦИЯ ОТРИСОВКИ (Draw) ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Карта
        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                const t = map[y][x];
                ctx.fillStyle = COLORS[t];
                ctx.fillRect(x * TILE_SIZE + 1, y * TILE_SIZE + 1, TILE_SIZE - 2, TILE_SIZE - 2);
                
                // Рисуем индикатор для EXIT плитки
                if (t === 6 && exitEnabled) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.moveTo(x * TILE_SIZE + 10, y * TILE_SIZE + 20);
                    ctx.lineTo(x * TILE_SIZE + 30, y * TILE_SIZE + 20);
                    ctx.lineTo(x * TILE_SIZE + 20, y * TILE_SIZE + 10);
                    ctx.closePath();
                    ctx.fill();
                } else if (t >= 1 && t <= 3) {
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.beginPath(); ctx.arc(x*TILE_SIZE+20, y*TILE_SIZE+20, 5, 0, Math.PI*2); ctx.fill();
                }
            }
        }

        // Враги
        enemies.forEach(e => {
            let rx = e.x * TILE_SIZE, ry = e.y * TILE_SIZE;
            if (e.moveProgress > 0) {
                rx += (e.targetX - e.x) * TILE_SIZE * e.moveProgress;
                ry += (e.targetY - e.y) * TILE_SIZE * e.moveProgress;
            }
            ctx.fillStyle = '#00FFFF';
            ctx.fillRect(rx + 8, ry + 8, 24, 24);
        });

        // Снаряды
        ctx.fillStyle = '#FFF';
        projectiles.forEach(p => {
            let px = (p.x * TILE_SIZE) + (p.dx * TILE_SIZE * p.progress) + 20;
            let py = (p.y * TILE_SIZE) + (p.dy * TILE_SIZE * p.progress) + 20;
            ctx.beginPath(); ctx.arc(px, py, 6, 0, Math.PI*2); ctx.fill();
        });

        // Взрывы
        ctx.fillStyle = '#FFA500';
        explosions.forEach(e => {
            let ex = e.x * TILE_SIZE + 20;
            let ey = e.y * TILE_SIZE + 20;
            ctx.beginPath(); ctx.arc(ex, ey, 20 + Math.random()*10, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FFFF00';
            ctx.beginPath(); ctx.arc(ex, ey, 10, 0, Math.PI*2); ctx.fill();
        });

        // Игрок
        let px = player.x * TILE_SIZE, py = player.y * TILE_SIZE;
        if (player.moving) {
            px += (player.targetX - player.x) * TILE_SIZE * player.moveProgress;
            py += (player.targetY - player.y) * TILE_SIZE * player.moveProgress;
        }
        let vy = py - player.jumpHeight;
        
        ctx.fillStyle = player.color;
        ctx.beginPath(); ctx.arc(px + 20, vy + 20, 12, 0, Math.PI*2); ctx.fill();

        let eyeX = px + 20 + player.lastDx * 8;
        let eyeY = vy + 20 + player.lastDy * 8;
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(eyeX, eyeY, 4, 0, Math.PI*2); ctx.fill();
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    // --- СТАРТ ИГРЫ ---
    loadLevel(currentLevelIndex);
    loop();
</script>
</body>
</html>